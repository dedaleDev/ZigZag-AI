//Auteur: Flavien Di√©val
package com.flavientech;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class App {
    private final String apiKeyPicoVoice = "NA0NuP+5Orn3NUuj8UHB6Sj1VaolSuM2qvYlQeeWbYs6epGzsACtYA==";  
    private final String apiKeyOpenAi = "sk-svcacct-zjaiQzqp_UELmtfRWJJdISaTt3ICHrOkeOU3tufzXe_ijWOoff8uWskYJK3yFxPT3BlbkFJeH3bRVzGMlZqLrrrynoDlsjKOl9ekB5QuKFTcJ6E0jM5-KqRgeiz2z2d43TW4AA";  
    private final String apiKeyWeather = "e7e87ddf5ee17846572597c477aa9b95"; 
    private final String comArduino = "/dev/tty.usbmodem14301"; // port s√©rie pour la communication avec l'Arduino

    private ArduinoSerial arduinoSerial;
    private static final int MAX_DATA_SIZE = 57;

    public static void main(String[] args) {
        App app = new App();
        Thread appThread = new Thread(() -> app.run());
        appThread.start();

        //run web server
        //ServeurWeb();
    }

    public void run() {
        this.arduinoSerial = new ArduinoSerial(comArduino);
        while (true) {
            try {
                // Lire les donn√©es re√ßues de l'Arduino
                byte[] receivedData = readFromArduino();
                if (receivedData != null) {
                    processReceivedData(receivedData);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }

    /**
     * Lecture des donn√©es re√ßues de l'Arduino
     */
    private byte[] readFromArduino() {
        try {
            InputStream inputStream = arduinoSerial.getSerialPort().getInputStream();
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    
            // Lire les 5 premiers octets (pr√©ambule + en-t√™te)
            long startTime = System.currentTimeMillis();
            while (buffer.size() < 5) {
                if (inputStream.available() > 0) {
                    buffer.write(inputStream.read());
                }
                // Timeout si aucune donn√©e n'arrive dans un d√©lai raisonnable
                if (System.currentTimeMillis() - startTime > 1000) {
                    System.err.println("‚ö†Ô∏è Timeout : aucune donn√©e re√ßue.");
                    return null;
                }
            }
    
            // R√©cup√©rer la longueur des donn√©es (2 derniers octets de l'en-t√™te)
            byte[] header = buffer.toByteArray();
            int dataLength = ByteBuffer.wrap(header, 3, 2).getShort();
    
            // Lire les donn√©es et la trame de stop
            while (buffer.size() < 5 + dataLength + 1) {
                if (inputStream.available() > 0) {
                    buffer.write(inputStream.read());
                }
                if (System.currentTimeMillis() - startTime > 2000) {
                    System.err.println("‚ö†Ô∏è Timeout : donn√©es incompl√®tes.");
                    return null;
                }
            }
            return buffer.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
     /**
     * Traitement des donn√©es re√ßues en fonction du pr√©ambule
     */
    private void processReceivedData(byte[] receivedData) throws IOException {
        if (receivedData == null || receivedData.length < 6) {
            System.err.println("‚ö†Ô∏è Donn√©es invalides ou trop courtes.");
            return;
        }
    
        byte preamble = receivedData[0];
        int unsignedPreamble = preamble & 0xFF;
    
        if (unsignedPreamble != 0b11100001 && unsignedPreamble != 0b11100010 && unsignedPreamble != 0b10100001) {
            System.err.println("‚ö†Ô∏è Pr√©ambule inconnu ou corrompu : " + Integer.toBinaryString(unsignedPreamble));
            return;
        }
    
        System.out.println("üîÑ Pr√©ambule valide re√ßu : " + Integer.toBinaryString(unsignedPreamble));
        byte[] header = new byte[4];
        System.arraycopy(receivedData, 1, header, 0, 4); // En-t√™te (4 octets)
        int numFrame = ByteBuffer.wrap(header, 0, 2).getShort(); // extraction des 2 premiers octets : num√©ro de trame en short
        int dataLength = ByteBuffer.wrap(header, 2, 2).getShort(); // 2 octets suivants : longueur des donn√©es
        // Validation de la longueur des donn√©es
        if (dataLength < 0 || dataLength > MAX_DATA_SIZE) {
            System.err.println("‚ö†Ô∏è Longueur de donn√©es incorrecte ERR0: " + dataLength);
            return;
        }

        // V√©rification de la longueur totale des donn√©es re√ßues
        if (receivedData.length < 5 + dataLength + 1) {
            System.err.println("‚ö†Ô∏è Donn√©es re√ßues incompl√®tes pour la taille annonc√©e. ERR1");
            return;
        }

        if (dataLength > MAX_DATA_SIZE) {
            System.err.println("‚ö†Ô∏è Taille des donn√©es trop grande : " + dataLength + " les donn√©es seront tronqu√©es. ERR 3 Pour  : " + unsignedPreamble + header + numFrame);
            dataLength = MAX_DATA_SIZE;
        }
        // Donn√©es
        byte[] data = new byte[dataLength];
        System.arraycopy(receivedData, 5, data, 0, dataLength);

        // Gestion des diff√©rents pr√©ambules
        switch (unsignedPreamble) {
            case 0b11100001: // Transmission audio
                System.out.println("üîÑ R√©ception d'une donn√©e audio (trame " + numFrame + ")");
                break;

            case  0b11100010: // Cr√©ation d'utilisateur
                System.out.println("üîÑ R√©ception d'une demande de cr√©ation d'utilisateur (trame " + numFrame + ")");
                break;

            case  0b10100001: // Trame de stop
                System.out.println("‚èπ R√©ception d'une trame de stop.");
                break;

            default:
                System.err.println("‚ö†Ô∏è Pr√©ambule inconnu : " + unsignedPreamble);
        }
    }



    /** -----------------------------------------------------------------runVoiceAI------------------------------------------------------
     * Ex√©cute l'assistant vocal.
     -----------------------------------------------------------------------------------------------------------------------------------------*/
    public void runVoiceAI() {
        List<String> users = EagleController.getUsersVoiceList();
        // show users 
        System.out.println("Liste des utilisateurs : " + users);
        long startTime = System.currentTimeMillis();

        // -------- d√©tection de l'utilisateur et Speech To Text --------  
        CompletableFuture<String> userDetectionFuture = CompletableFuture.supplyAsync(() -> detectSpeakingUser(users));
        CompletableFuture<String> speechToTextFuture = CompletableFuture.supplyAsync(this::runSpeechToText);
        CompletableFuture<Void> combinedFuture = CompletableFuture.allOf(userDetectionFuture, speechToTextFuture); //attendre la fin

        combinedFuture.thenRun(() -> {// Attendre que les deux t√¢ches soient termin√©es avant de continuer
            try {
                //r√©cup√©rer les r√©sultats
                String currentSpeakingUser = userDetectionFuture.get();
                System.out.println("Utilisateur courant : " + currentSpeakingUser);
                String userRequest = speechToTextFuture.get();

                long endTime = System.currentTimeMillis();
                System.out.println("Temps d'ex√©cution de la detection d'utilisateur + STT : " + (endTime - startTime) + " ms");
                // --------------- Appel √† l'API OpenAI ---------------
                String openAIResponse = interactWithOpenAI(currentSpeakingUser, userRequest);

                // --------------- Synth√®se vocale de la r√©ponse ---------------
                if (openAIResponse != null) {
                    new textToSpeech(openAIResponse);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).join();  // Attendre que toutes les t√¢ches soient termin√©es avant de terminer le programme.
    }


    /**------------------------------------------------------detectSpeakingUser------------------------------------------------------
     * D√©tecte l'utilisateur avec EagleController et ex√©cute la reconnaissance vocale pour chaque utilisateur.
     * Retourne l'utilisateur avec le score le plus √©lev√©.
     * @param users Liste des utilisateurs √† tester
     -----------------------------------------------------------------------------------------------------------------------------------------*/
    private String detectSpeakingUser(List<String> users) {
        if (users == null || users.isEmpty()) {
            System.out.println("Aucun utilisateur trouv√©.");
            return "Utilisateur inconnu";
        }
        float[] scoreBoard = new float[users.size()];
        long startTime = System.currentTimeMillis();
        List<CompletableFuture<Void>> futures = new ArrayList<>();// CompletableFuture -> threads efficace selon doc
        for (int i = 0; i < users.size(); i++) {
            String user = users.get(i);
            int index = i;
            futures.add(CompletableFuture.runAsync(() -> {
                scoreBoard[index] = EagleController.runTest(apiKeyPicoVoice, user, "src/caches/request.wav");
                System.out.println("Utilisateur: " + user + ", Score: " + scoreBoard[index]);
            }));
        }
        // --- running threads ---
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // --------- Calcul du score le plus √©lev√© ---------
        float maxScore = 0;
        int maxIndex = -1;
        for (int i = 0; i < scoreBoard.length; i++) {
            float score = scoreBoard[i];
            if (score == -1) {
                System.out.println("\u001B[31mErreur lors de la reconnaissance vocale de l'utilisateur " + users.get(i) + "\u001B[0m");
                continue; 
            }
            if (score > maxScore) {
                maxScore = score;
                maxIndex = i;
            }
        }
        String detectedUser = "Utilisateur inconnu";
        if (maxIndex != -1 && maxScore > 0) {
            detectedUser = users.get(maxIndex);
        }
        System.out.println("Temps d'ex√©cution  de la detection d'utilisateur : " + (System.currentTimeMillis() - startTime) + " ms");
        return detectedUser;
    }

    /** ------------------------------------------------------runSpeechToText------------------------------------------------------
     * Ex√©cute la reconnaissance vocale pour convertir la voix en texte.
     -----------------------------------------------------------------------------------------------------------------------------------------*/
    private String runSpeechToText() {
        try {
            long startTime = System.currentTimeMillis();
            speechToText recognizer = new speechToText(apiKeyPicoVoice);
            String result = recognizer.run("src/caches/request.wav");
            System.out.println("\u001B[33mRequ√™te utilisateur : " + result + "\u001B[0m");
            System.out.println("Temps d'ex√©cution : du speech to text " + (System.currentTimeMillis() - startTime) + " ms");
            return result;
        } catch (Exception e) {
            if (e.getMessage().contains("0000012C")){
                System.out.println("\u001B[31mErreur STT : fichier audio incorrect ou inexistant\u001B[0m");
            }
            e.printStackTrace();
        }
        return null;
    }

    /**------------------------------------------------------interactWithOpenAI------------------------------------------------------
     * Interagit avec l'API OpenAI pour obtenir une r√©ponse √† la requ√™te de l'utilisateur.
     -----------------------------------------------------------------------------------------------------------------------------------------*/
    private String interactWithOpenAI(String currentUser, String userRequest) {
        System.out.println("Waiting for inference...");
        OpenAI api = new OpenAI(this.apiKeyOpenAi);
        api.setCurrentUser(currentUser);

        String context = Memory.getLongMemory();
        String initialRequest = currentUser.concat(" te demande : ").concat(userRequest);
        String apiResponse = api.sendRequest(initialRequest, context);

        // Rafra√Æchir la m√©moire avec la nouvelle conversation
        Memory.refreshFlashMemory("Question pr√©c√©dentes : ".concat(userRequest).concat("\nTu avais r√©pondu : ").concat(api.cleanResponse(apiResponse).split("@")[0]));

        // --------   V√©rifier s'il y a une action sp√©ciale √† effectuer
        String finalResponse = api.specialFunction(apiResponse, apiKeyWeather, userRequest);
       
        //met √† jour la m√©moire avec la r√©ponse finale
       if (finalResponse != null) {
            finalResponse = Memory.addData(api.cleanText(finalResponse));
        }
        return finalResponse;
    }
}