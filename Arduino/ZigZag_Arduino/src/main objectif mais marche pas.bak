#include <Arduino.h>
#include <SPI.h>
#include <Adafruit_VS1053.h>
#include <SD.h>

#define SD_CS 9
#define MISO 12
#define MOSI 11
#define SCK 13
#define XCS 6
#define XRESET 8
#define XDSC 7
#define DREQ 2

#define RECBUFFSIZE 256
#define CHUNK_SIZE 57// Taille maximale des données dans une trame
#define SERIAL_BAUD_RATE 9600  // Vitesse de la liaison série

Adafruit_VS1053_FilePlayer musicPlayer = Adafruit_VS1053_FilePlayer(XRESET, XCS, XDSC, DREQ, SD_CS);
File recording;
uint8_t recording_buffer[RECBUFFSIZE];

File oggFile;
uint16_t frameNumber = 0; // Numéro de trame


uint16_t saveRecordedData(boolean isrecord) {
    // Fonction pour enregistrer les données sur la carte SD
    uint16_t written = 0;
    uint16_t wordsWaiting = musicPlayer.recordedWordsWaiting();
    while (wordsWaiting > 0) {
        uint16_t toRead = min(wordsWaiting, RECBUFFSIZE / 2);
        for (uint16_t addr = 0; addr < toRead * 2; addr += 2) {
            uint16_t t = musicPlayer.recordedReadWord();
            recording_buffer[addr] = t >> 8;
            recording_buffer[addr + 1] = t;
        }
        if (!recording.write(recording_buffer, toRead * 2)) {
            Serial.println("Couldn't write to file!");
            while (1);
        }
        written += toRead;
        wordsWaiting -= toRead;
    }
    if (!isrecord) {
        musicPlayer.sciRead(VS1053_SCI_AICTRL3);
        if (!(musicPlayer.sciRead(VS1053_SCI_AICTRL3) & (1 << 2))) {
            uint16_t lastWord = musicPlayer.recordedReadWord();
            recording.write(lastWord & 0xFF);
            written++;
        }
    }
    return written;
}


void sendFrame(uint8_t preamble, uint8_t *data, size_t length) {
    // Fonction pour envoyer une trame
    // Envoi du préambule
    Serial.write(preamble);

    // Envoi de l'en-tête
    Serial.write((uint8_t)(frameNumber >> 8));    // Numéro de trame (MSB)
    Serial.write((uint8_t)(frameNumber & 0xFF)); // Numéro de trame (LSB)
    Serial.write((uint8_t)(length >> 8));        // Longueur des données (MSB)
    Serial.write((uint8_t)(length & 0xFF));      // Longueur des données (LSB)

    // Envoi des données
    Serial.write(data, length);

    Serial.write(0b10101110); 

    // Incrémentation du numéro de trame
    frameNumber++;
}

void sendAudio(){
    if (oggFile.available()) {
        // Lecture d'une trame de données
        uint8_t buffer[CHUNK_SIZE];
        size_t bytesRead = oggFile.read(buffer, CHUNK_SIZE);

        // Envoi de la trame avec le préambule 0b11100001 (transmission audio)
        sendFrame(0b11100001, buffer, bytesRead);
    } else {
        // Envoi de la trame de stop
        uint8_t dummyData[0] = {};
        sendFrame(0b10100001, dummyData, 0);

        // Fin de transmission
        oggFile.close();
        Serial.println("Fichier envoyé !");
        while (1)
        ; // Arrêter le programme
    }
}

void setup() {
    Serial.begin(SERIAL_BAUD_RATE); 
    Serial.println("Adafruit VS1053 Ogg record");

    if (!musicPlayer.begin()) {
        Serial.println("VS1053 not found");
        while (1);
    }

    musicPlayer.sineTest(0x44, 500);

    if (!SD.begin(SD_CS)) {
        Serial.println("SD failed, or not present");
        while (1);
    }
    Serial.println("SD OK!");

    musicPlayer.setVolume(10, 10);

    if (!musicPlayer.prepareRecordOgg("v44k1q05.img")) {
        Serial.println("Couldn't load plugin!");
        while (1);
    }
    pinMode(10, OUTPUT); // LED de contrôle
    pinMode(4, INPUT);   // Bouton poussoir
    Serial.println("Ready to record!");
}

uint8_t isRecording = false;


void loop() {
    digitalWrite(10, LOW);
    if (digitalRead(4) == HIGH) {
        Serial.println("Button pressed, starting recording...");
        digitalWrite(10, HIGH);
        isRecording = true;

        const char* filename = "RECORD.OGG";

        Serial.print("Recording to ");
        Serial.println(filename);

        // Supprimer le fichier existant
        if (SD.exists(filename)) {
            SD.remove(filename);
            Serial.println("Fichier RECORD.OGG supprimé.");
        }

        recording = SD.open(filename, FILE_WRITE);
        if (!recording) {
            Serial.println("Couldn't open file to record!");
            while (1);
        }
        musicPlayer.startRecordOgg(true);
    }

    if (isRecording) {
        while (digitalRead(4) != LOW) {
            uint16_t written = saveRecordedData(isRecording);
            if (written < 32) {
                delay(1);
            }
        }
        musicPlayer.stopRecordOgg();
        isRecording = false;
        saveRecordedData(isRecording);
        recording.flush();
        recording.close();
        Serial.println("End recording");
        digitalWrite(10, LOW);

        // Envoi du fichier enregistré
        oggFile = SD.open("RECORD.ogg", FILE_READ);
        if (!oggFile) {
            Serial.println("Erreur : Fichier RECORD.ogg introuvable !");
            while (1);
        }
        Serial.println("Début de l'envoi du fichier...");
        sendAudio();
        Serial.println("Fichier envoyé !");

        if (!musicPlayer.prepareRecordOgg("v44k1q05.img")) {// Recharger le plugin pour la prochaine session de record
            Serial.println("Couldn't load plugin!");
            while (1);
        }
    }
}